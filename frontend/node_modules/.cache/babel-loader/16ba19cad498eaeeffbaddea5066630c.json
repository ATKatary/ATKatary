{"ast":null,"code":"/*** Global Constants ***/\n\n/*** Interfaces ***/\n\n/*** Classes ***/\nclass Rect {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  overlaps(a, b) {\n    if (a <= this.x1 && this.x1 <= b) return true;\n    if (a <= this.x2 && this.x2 <= b) return true;\n    return false;\n  }\n\n}\n\nexport class Card {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.angle = 0;\n    this.rect = void 0;\n    this.margin = 0;\n    this.center = void 0;\n    this.rect = new Rect(0, 0, width, height);\n    this.center = width / 2;\n  }\n  /**\n   * \n   * @param a \n   * @param b \n   */\n  // public peak(a: number, b: number): {x: number, y: number} {\n  // const x1 = this.center - this.width / 2;\n  // const x2 = this.width * Math.cos(this.angle);\n  // const y2 = this.width * Math.sin(this.angle) + this.rect.y2;\n  // const y1 = this.height * Math.cos(this.angle);\n  // const f = (x: number) => (y1 - y2) / (x1 - x2) * (x - x2) + y2;\n  // console.log(`Finding the peak of (${x1}, ${x2}) on interval (${a}, ${b})`)\n  // console.log(`x1: ${x1} -> ${y1}\\nx2: ${x2} -> ${y2}\\na: ${a} -> ${f(a)}\\nb: ${b} -> ${f(b)}`)\n  // if (x1< a && b < x2) return f(a) > f(b) ? {x: a, y: f(a)} : {x: b, y: f(b)};\n  // if (x1 < a && b > x2) return f(a) > y2 ? {x: a, y: f(a)} : {x: x2, y: y2};\n  // if (x1 > a && b > x2) return y1 > y2 ? {x: x1, y: y1} : {x: x2, y: y2};\n  // if (x1 >= a && b <= x2) return y1 > f(b) ? {x: x1, y: y1} : {x: b, y: f(b)};\n  // else throw new Error(\"Specification violated\");\n  // }\n\n\n}\nexport class CardBucket2D {\n  /*** Representation ***/\n\n  /** \n   * AF(cards) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(size) {\n    this.size = size;\n    this.cards = [];\n  }\n  /** @inheritdoc */\n\n\n  drop(card) {\n    const w = card.width;\n    const center = Math.random() * (this.size.width - w + 1) + w / 2;\n\n    const leftPeak = this._peak(center - w / 2, center);\n\n    const rightPeak = this._peak(center, center + w / 2);\n\n    console.log(\"right peak\", rightPeak, \"left peak\", leftPeak);\n    card.center = center;\n    card.margin = (leftPeak.y + rightPeak.y) / 2; // if (card.margin !== 0) card.angle = Math.atan((leftPeak.y - rightPeak.y) / (leftPeak.x - rightPeak.x));\n\n    card.rect = new Rect(center - w / 2, card.margin, center + w / 2, card.margin + card.height);\n    this.cards.push(card);\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Finds the card with the highest peak within the interval [a, b]\n   * \n   * @param a the start of the interval, must be 0 <= a <= this.width\n   * @param b the end of the interval, must be 0 <= a < b <= this.width\n   * @returns the coordinates of the peak within the interval and has the heighest peak\n   */\n\n\n  _peak(a, b) {\n    let peak = {\n      x: 0,\n      y: 0\n    };\n\n    for (const card of this.cards) {\n      if (!card.rect.overlaps(a, b)) continue;\n      console.log(\"Found an overlap!\"); // const cardPeak = card.peak(a, b);\n\n      const cardPeak = {\n        x: 0,\n        y: card.rect.y2\n      };\n      if (cardPeak.y > peak.y || cardPeak.y === peak.y && cardPeak.x > peak.x) peak = cardPeak;\n    }\n\n    return peak;\n  }\n\n}","map":{"version":3,"sources":["/Users/king_ahmed1421/Simba/Ahmed/frontend/src/gallery/utils.ts"],"names":["Rect","constructor","x1","y1","x2","y2","overlaps","a","b","Card","width","height","angle","rect","margin","center","CardBucket2D","size","cards","drop","card","w","Math","random","leftPeak","_peak","rightPeak","console","log","y","push","peak","x","cardPeak"],"mappings":"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","sourcesContent":["/*** Global Constants ***/\n\n/*** Interfaces ***/\ninterface CardBucket {\n    /*** Required Representation ***/\n    \n    readonly cards: Array<Card>;\n    readonly size: {width: number, height: number};\n\n    /**\n     * Drops a card into the bucket such that the droped card is either on the floor\n     * of the bucket or is adjacent but not overlapping another card\n     * \n     * @param card to drop into the bucket, must be smaller in size than the bucket\n     */\n    drop(card: Card): void;\n}\n\n/*** Classes ***/\nclass Rect {\n    /*** Representation ***/\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(public readonly x1: number, public readonly y1: number, public readonly x2: number, public readonly y2: number) {}\n\n    public overlaps(a: number, b: number): boolean {\n        if (a <= this.x1 && this.x1 <= b) return true;\n        if (a <= this.x2 && this.x2 <= b) return true;\n        return false;\n    }\n}\nexport class Card {\n    /*** Representation ***/\n    public angle = 0;\n    public rect: Rect;\n    public margin = 0;\n    public center: number;\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly width: number, readonly height: number) {\n        this.rect = new Rect(0, 0, width, height);\n        this.center = width / 2;\n    }\n\n    /**\n     * \n     * @param a \n     * @param b \n     */\n    // public peak(a: number, b: number): {x: number, y: number} {\n        // const x1 = this.center - this.width / 2;\n        // const x2 = this.width * Math.cos(this.angle);\n        // const y2 = this.width * Math.sin(this.angle) + this.rect.y2;\n        // const y1 = this.height * Math.cos(this.angle);\n        // const f = (x: number) => (y1 - y2) / (x1 - x2) * (x - x2) + y2;\n\n        // console.log(`Finding the peak of (${x1}, ${x2}) on interval (${a}, ${b})`)\n        // console.log(`x1: ${x1} -> ${y1}\\nx2: ${x2} -> ${y2}\\na: ${a} -> ${f(a)}\\nb: ${b} -> ${f(b)}`)\n        \n        // if (x1< a && b < x2) return f(a) > f(b) ? {x: a, y: f(a)} : {x: b, y: f(b)};\n        // if (x1 < a && b > x2) return f(a) > y2 ? {x: a, y: f(a)} : {x: x2, y: y2};\n        // if (x1 > a && b > x2) return y1 > y2 ? {x: x1, y: y1} : {x: x2, y: y2};\n        // if (x1 >= a && b <= x2) return y1 > f(b) ? {x: x1, y: y1} : {x: b, y: f(b)};\n        // else throw new Error(\"Specification violated\");\n\n    // }\n}\n\nexport class CardBucket2D implements CardBucket {\n    /*** Representation ***/\n    readonly cards: Card[] = [];\n\n    /** \n     * AF(cards) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly size: {width: number, height: number}) {}\n\n    /** @inheritdoc */\n    public drop(card: Card): void {\n        const w = card.width;\n        const center = Math.random() * (this.size.width - w + 1) + w / 2;\n\n        const leftPeak = this._peak(center - w / 2, center);\n        const rightPeak = this._peak(center, center + w / 2);\n        console.log(\"right peak\", rightPeak, \"left peak\", leftPeak)\n        card.center = center;\n        card.margin = (leftPeak.y + rightPeak.y) / 2;\n        // if (card.margin !== 0) card.angle = Math.atan((leftPeak.y - rightPeak.y) / (leftPeak.x - rightPeak.x));\n        card.rect = new Rect(center - w / 2, card.margin,  center + w / 2, card.margin + card.height)\n        this.cards.push(card);\n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Finds the card with the highest peak within the interval [a, b]\n     * \n     * @param a the start of the interval, must be 0 <= a <= this.width\n     * @param b the end of the interval, must be 0 <= a < b <= this.width\n     * @returns the coordinates of the peak within the interval and has the heighest peak\n     */\n    private _peak(a: number, b: number): {x: number, y: number} {\n        let peak = {x: 0, y: 0};\n        for (const card of this.cards) {\n            if (!card.rect.overlaps(a, b)) continue;\n            console.log(\"Found an overlap!\")\n\n            // const cardPeak = card.peak(a, b);\n            const cardPeak = {x: 0, y: card.rect.y2}\n            if (cardPeak.y > peak.y || (cardPeak.y === peak.y && cardPeak.x > peak.x)) peak = cardPeak;\n        }\n\n        return peak;\n    }\n}"]},"metadata":{},"sourceType":"module"}