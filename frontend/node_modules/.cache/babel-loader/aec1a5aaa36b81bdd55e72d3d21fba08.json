{"ast":null,"code":"/*** Global Constants ***/\nconst c = (x, y) => {\n  return {\n    x: x,\n    y: y\n  };\n};\n/*** Interfaces ***/\n\n\n/*** Classes ***/\nclass Rect {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(c1, c2, c3, c4) {\n    this.c1 = c1;\n    this.c2 = c2;\n    this.c3 = c3;\n    this.c4 = c4;\n  }\n\n  overlaps(a, b) {}\n  /**\n   * Calculates the hieght of any point along the domain of the rectangle\n   * @param x \n   * @returns \n   */\n\n\n  _h(x) {\n    if (Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x) > x) throw new Error(\"x out of bounds\");\n    if (Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x) < x) throw new Error(\"x out of bounds\");\n    return (this.c3.y - this.c4.y) / (this.c3.x - this.c4.x) * (x = this.c3.x) + this.c3.y;\n  }\n\n}\n\nexport class Card {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.angle = 0;\n    this.rect = void 0;\n    this.margin = 0;\n    this.center = void 0;\n    this.rect = new Rect(c(0, 0), c(width, 0), c(width, height), c(0, height));\n    this.center = width / 2;\n  }\n  /**\n   * \n   * @param a \n   * @param b \n   */\n\n\n  peak(a, b) {}\n\n}\nexport class CardBucket2D {\n  /*** Representation ***/\n\n  /** \n   * AF(cards) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(size) {\n    this.size = size;\n    this.cards = [];\n  }\n  /** @inheritdoc */\n\n\n  drop(card) {\n    const w = card.width;\n    const center = Math.random() * (this.size.width - w + 1) + w / 2;\n    const x1 = center - w / 2;\n    const x2 = center + w / 2;\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Finds the card with the highest peak within the interval [a, b]\n   * \n   * @param a the start of the interval, must be 0 <= a <= this.width\n   * @param b the end of the interval, must be 0 <= a < b <= this.width\n   * @returns the coordinates of the peak within the interval and has the heighest peak\n   */\n\n\n  _peak(a, b) {}\n\n}","map":{"version":3,"sources":["/Users/king_ahmed1421/Simba/Ahmed/frontend/src/gallery/utils.ts"],"names":["c","x","y","Rect","constructor","c1","c2","c3","c4","overlaps","a","b","_h","Math","min","Error","max","Card","width","height","angle","rect","margin","center","peak","CardBucket2D","size","cards","drop","card","w","random","x1","x2","_peak"],"mappings":"AAAA;AACA,MAAMA,CAAC,GAAG,CAACC,CAAD,EAAYC,CAAZ,KAA0B;AAAC,SAAO;AAACD,IAAAA,CAAC,EAAEA,CAAJ;AAAOC,IAAAA,CAAC,EAAEA;AAAV,GAAP;AAAqB,CAA1D;AAEA;;;AAgBA;AACA,MAAMC,IAAN,CAAW;AACP;;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AAEIC,EAAAA,WAAW,CAAiBC,EAAjB,EACiBC,EADjB,EAEiBC,EAFjB,EAGiBC,EAHjB,EAG6C;AAAA,SAH5BH,EAG4B,GAH5BA,EAG4B;AAAA,SAF5BC,EAE4B,GAF5BA,EAE4B;AAAA,SAD5BC,EAC4B,GAD5BA,EAC4B;AAAA,SAA5BC,EAA4B,GAA5BA,EAA4B;AAAE;;AAEnDC,EAAAA,QAAQ,CAACC,CAAD,EAAYC,CAAZ,EAAgC,CAE9C;AAED;AACJ;AACA;AACA;AACA;;;AACYC,EAAAA,EAAE,CAACX,CAAD,EAAoB;AAC1B,QAAIY,IAAI,CAACC,GAAL,CAAS,KAAKT,EAAL,CAAQJ,CAAjB,EAAoB,KAAKK,EAAL,CAAQL,CAA5B,EAA+B,KAAKM,EAAL,CAAQN,CAAvC,EAA0C,KAAKO,EAAL,CAAQP,CAAlD,IAAuDA,CAA3D,EAA8D,MAAM,IAAIc,KAAJ,CAAU,iBAAV,CAAN;AAC9D,QAAIF,IAAI,CAACG,GAAL,CAAS,KAAKX,EAAL,CAAQJ,CAAjB,EAAoB,KAAKK,EAAL,CAAQL,CAA5B,EAA+B,KAAKM,EAAL,CAAQN,CAAvC,EAA0C,KAAKO,EAAL,CAAQP,CAAlD,IAAuDA,CAA3D,EAA8D,MAAM,IAAIc,KAAJ,CAAU,iBAAV,CAAN;AAC9D,WAAO,CAAC,KAAKR,EAAL,CAAQL,CAAR,GAAY,KAAKM,EAAL,CAAQN,CAArB,KAA2B,KAAKK,EAAL,CAAQN,CAAR,GAAY,KAAKO,EAAL,CAAQP,CAA/C,KAAqDA,CAAC,GAAG,KAAKM,EAAL,CAAQN,CAAjE,IAAsE,KAAKM,EAAL,CAAQL,CAArF;AACH;;AA9BM;;AAiCX,OAAO,MAAMe,IAAN,CAAW;AACd;;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AAEIb,EAAAA,WAAW,CAAUc,KAAV,EAAkCC,MAAlC,EAAkD;AAAA,SAAxCD,KAAwC,GAAxCA,KAAwC;AAAA,SAAhBC,MAAgB,GAAhBA,MAAgB;AAAA,SAdtDC,KAcsD,GAd9C,CAc8C;AAAA,SAbtDC,IAasD;AAAA,SAZtDC,MAYsD,GAZ7C,CAY6C;AAAA,SAXtDC,MAWsD;AACzD,SAAKF,IAAL,GAAY,IAAIlB,IAAJ,CAASH,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAV,EAAkBA,CAAC,CAACkB,KAAD,EAAQ,CAAR,CAAnB,EAA+BlB,CAAC,CAACkB,KAAD,EAAQC,MAAR,CAAhC,EAAiDnB,CAAC,CAAC,CAAD,EAAImB,MAAJ,CAAlD,CAAZ;AACA,SAAKI,MAAL,GAAcL,KAAK,GAAG,CAAtB;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACWM,EAAAA,IAAI,CAACd,CAAD,EAAYC,CAAZ,EAA+C,CAEzD;;AA5Ba;AA+BlB,OAAO,MAAMc,YAAN,CAAyC;AAC5C;;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AAEIrB,EAAAA,WAAW,CAAUsB,IAAV,EAAiD;AAAA,SAAvCA,IAAuC,GAAvCA,IAAuC;AAAA,SAXnDC,KAWmD,GAXnC,EAWmC;AAAE;AAE9D;;;AACOC,EAAAA,IAAI,CAACC,IAAD,EAAmB;AAC1B,UAAMC,CAAC,GAAGD,IAAI,CAACX,KAAf;AACA,UAAMK,MAAM,GAAGV,IAAI,CAACkB,MAAL,MAAiB,KAAKL,IAAL,CAAUR,KAAV,GAAkBY,CAAlB,GAAsB,CAAvC,IAA4CA,CAAC,GAAG,CAA/D;AAEA,UAAME,EAAE,GAAGT,MAAM,GAAGO,CAAC,GAAG,CAAxB;AACA,UAAMG,EAAE,GAAGV,MAAM,GAAGO,CAAC,GAAG,CAAxB;AAIH;AAED;;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACYI,EAAAA,KAAK,CAACxB,CAAD,EAAYC,CAAZ,EAA+C,CAE3D;;AArC2C","sourcesContent":["/*** Global Constants ***/\nconst c = (x: number, y: number) => {return {x: x, y: y};};\n\n/*** Interfaces ***/\ninterface CardBucket {\n    /*** Required Representation ***/\n    \n    readonly cards: Array<Card>;\n    readonly size: {width: number, height: number};\n\n    /**\n     * Drops a card into the bucket such that the droped card is either on the floor\n     * of the bucket or is adjacent but not overlapping another card\n     * \n     * @param card to drop into the bucket, must be smaller in size than the bucket\n     */\n    drop(card: Card): void;\n}\n\n/*** Classes ***/\nclass Rect {\n    /*** Representation ***/\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(public readonly c1: {x: number, y: number},\n                public readonly c2: {x: number, y: number},\n                public readonly c3: {x: number, y: number},\n                public readonly c4: {x: number, y: number}) {}\n\n    public overlaps(a: number, b: number): boolean {\n        \n    }\n\n    /**\n     * Calculates the hieght of any point along the domain of the rectangle\n     * @param x \n     * @returns \n     */\n    private _h(x: number): number {\n        if (Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x) > x) throw new Error(\"x out of bounds\");\n        if (Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x) < x) throw new Error(\"x out of bounds\");\n        return (this.c3.y - this.c4.y) / (this.c3.x - this.c4.x) * (x = this.c3.x) + this.c3.y;\n    } \n}\n\nexport class Card {\n    /*** Representation ***/\n    public angle = 0;\n    public rect: Rect;\n    public margin = 0;\n    public center: number;\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly width: number, readonly height: number) {\n        this.rect = new Rect(c(0, 0), c(width, 0), c(width, height), c(0, height));\n        this.center = width / 2;\n    }\n\n    /**\n     * \n     * @param a \n     * @param b \n     */\n    public peak(a: number, b: number): {x: number, y: number} {\n        \n    }\n}\n\nexport class CardBucket2D implements CardBucket {\n    /*** Representation ***/\n    readonly cards: Card[] = [];\n\n    /** \n     * AF(cards) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly size: {width: number, height: number}) {}\n\n    /** @inheritdoc */\n    public drop(card: Card): void {\n        const w = card.width;\n        const center = Math.random() * (this.size.width - w + 1) + w / 2;\n\n        const x1 = center - w / 2; \n        const x2 = center + w / 2\n\n\n        \n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Finds the card with the highest peak within the interval [a, b]\n     * \n     * @param a the start of the interval, must be 0 <= a <= this.width\n     * @param b the end of the interval, must be 0 <= a < b <= this.width\n     * @returns the coordinates of the peak within the interval and has the heighest peak\n     */\n    private _peak(a: number, b: number): {x: number, y: number} {\n        \n    }\n}"]},"metadata":{},"sourceType":"module"}