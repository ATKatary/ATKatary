{"ast":null,"code":"/*** Global Constants ***/\nconst c = (x, y) => {\n  return {\n    x: x,\n    y: y\n  };\n};\n/*** Interfaces ***/\n\n\n/*** Classes ***/\nclass Rect {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(c1, c2, c3, c4) {\n    this.c1 = c1;\n    this.c2 = c2;\n    this.c3 = c3;\n    this.c4 = c4;\n  }\n  /**\n   * Checks if a rectangle overlaps the interval [a, b], requires a <= b\n   * \n   * @param a the start of the interval\n   * @param b the end of the interval\n   * @returns true if this rectangle overlaps [a, b], false otherwise\n   */\n\n\n  overlaps(a, b) {\n    return this._overlappingIntervals([a, b], [this.c1.x, this.c2.x]) || this._overlappingIntervals([a, b], [this.c4.x, this.c3.x]);\n  }\n  /**\n   * Finds the peak of this rectangle, i.e the highest point on this rectangle's within an interval\n   * [a, b], requires a <= b and this rectangle overlap the interval\n   * \n   * Definitions\n   *      peak: the highest point on the perimeter of a rectangle\n   *      ------- <-- any of these points are the highest peak\n   *      |     |\n   *      -------\n   * \n   * \n   * @param a the beggining of the interval\n   * @param b the end of the interval\n   * @returns the peak of this rectangle on the itnerval [a, b]\n   */\n\n\n  peak(a, b) {\n    const aY = this._h(a);\n\n    const bY = this._h(b);\n\n    const x = [a, b, this.c1.x, this.c2.x, this.c3.x, this.c4.x];\n    const y = [aY, bY, this.c1.y, this.c2.y, this.c3.y, this.c4.y];\n    return {\n      x: x[y.indexOf(Math.max(...y))],\n      y: Math.max(...y)\n    };\n  }\n  /**\n   * Rotates a rectangle by an angle about the center of the rectangle\n   * \n   * @param angle the angle to rotate the rectangle by, in degrees\n   * @returns \n   */\n\n\n  rotate(angle) {\n    const c1 = this._rotatePoint(angle, this.c1);\n\n    const c2 = this._rotatePoint(angle, this.c2);\n\n    const c3 = this._rotatePoint(angle, this.c3);\n\n    const c4 = this._rotatePoint(angle, this.c4);\n\n    return new Rect(c1, c2, c3, c4);\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  toString() {\n    return `----- Rect -----\\n\\tC1: (${Math.round(this.c4.x)}, ${Math.round(this.c4.y)})\\n\\tC2: (${Math.round(this.c3.x)}, ${Math.round(this.c3.y)})\\n\\tC3: (${Math.round(this.c1.x)}, ${Math.round(this.c1.y)})\\n\\tC4: (${Math.round(this.c2.x)}, ${Math.round(this.c2.y)})\\n\\t----- ---- -----`;\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Calculates the hieght of any point along the domain of the rectangle\n   * \n   * @param x a number on the domain of the rectangle \n   * @returns the height of the rectangle at point x\n   */\n\n\n  _h(x) {\n    if (Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x) > x) return 0;\n    if (Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x) < x) return 0;\n    return (this.c3.y - this.c4.y) / (this.c3.x - this.c4.x) * (x - this.c3.x) + this.c3.y;\n  }\n  /**\n   * Rotates a point by the given angle \n   * R(x, y, 𝜽) = (x*cos(𝜽)) - y*sin(𝜽), x*sin(𝜽) + y*cos(𝜽))\n   * \n   * @param angle to rotate the point by, in degrees\n   * @param point to rotate\n   * @returns the coordinates of the rotates point\n   */\n\n\n  _rotatePoint(angle, point) {\n    angle *= Math.PI / 180;\n    return {\n      x: point.x * Math.cos(angle) - point.y * Math.sin(angle),\n      y: point.x * Math.sin(angle) + point.y * Math.cos(angle)\n    };\n  }\n  /**\n   * Checks if two intervals overlap, requires each interval to be of the form [a, b]\n   * where a <= b\n   * \n   * Definitions\n   *      overlap: line segments sharing a segement\n   *                  -------\n   *             -------\n   *  \n   * @param interval1 the first interval\n   * @param interval2 the second interval\n   * @returns true if the intervals overlap, false otherwise\n   */\n\n\n  _overlappingIntervals(interval1, interval2) {\n    const [a, b] = interval1;\n    const [c, d] = interval2;\n    if (d < a || b < c) return false;\n    return true;\n  }\n\n}\n\nexport class Card {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.angle = 0;\n    this.rect = void 0;\n    this.marginTop = 0;\n    this.center = void 0;\n    this.marginLeft = 0;\n    this.rect = new Rect(c(0, 0), c(width, 0), c(width, height), c(0, height));\n    this.center = width / 2;\n  }\n  /**\n   * \n   */\n\n\n  copy() {\n    const copy = new Card(this.width, this.height);\n    copy.rect = this.rect;\n    copy.center = this.center;\n    copy.marginTop = this.marginTop;\n    copy.marginLeft = this.marginLeft;\n    return copy;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  toString() {\n    return `----- Card -----\\n\\t${this.rect}\\n\\tCenter: ${this.center}\\n\\tRotation Angle: ${this.angle}\\n\\tMarginTop: ${this.marginTop}\\n\\tMarginLeft: ${this.marginLeft}`;\n  }\n\n}\nexport class CardBucket2D {\n  /*** Representation ***/\n\n  /** \n   * AF(cards) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(size) {\n    this.size = size;\n    this.cards = [];\n  }\n  /** @inheritdoc */\n\n\n  drop(card) {\n    const cardCopy = card.copy();\n    const w = cardCopy.width;\n    cardCopy.center = Math.random() * (this.size.width - w) + w / 2;\n    const x1 = cardCopy.center - w / 2;\n    const x2 = cardCopy.center + w / 2;\n    cardCopy.marginLeft = x1;\n    cardCopy.rect = new Rect(c(x1, 0), c(x2, 0), c(x2, cardCopy.height), c(x1, cardCopy.height));\n\n    const leftPeak = this._peak(x1, cardCopy.center - 1);\n\n    const rightPeak = this._peak(cardCopy.center, x2);\n\n    const y1 = Math.max(leftPeak.y, rightPeak.y);\n    cardCopy.rect = new Rect(c(x1, y1), c(x2, y1), c(x2, y1 + cardCopy.height), c(x1, y1 + cardCopy.height));\n    const deltaX = leftPeak.y - rightPeak.y;\n    const deltaY = leftPeak.x - rightPeak.x; // if (deltaX !== 0) cardCopy.angle = Math.atan(deltaY / deltaX) * 180 / Math.PI;\n    // cardCopy.rect = cardCopy.rect.rotate(cardCopy.angle);\n\n    cardCopy.marginTop = this.size.height - (cardCopy.rect.c1.y + cardCopy.rect.c2.y) / 2;\n    if (cardCopy.marginTop < 0) this.drop(card);\n    console.log(`Dropped card ${this.cards.length}:\\n${cardCopy}`);\n    this.cards.push(cardCopy);\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Finds the card with the highest peak within the interval [a, b]\n   * \n   * @param a the start of the interval, must be 0 <= a <= this.width\n   * @param b the end of the interval, must be 0 <= a < b <= this.width\n   * @returns the coordinates of the peak within the interval and has the heighest peak\n   */\n\n\n  _peak(a, b) {\n    console.log(`Searching for overlap on [${Math.round(a)}, ${Math.round(b)}] ....`);\n    let peak = {\n      x: a,\n      y: 0\n    };\n\n    for (const card of this.cards) {\n      if (!card.rect.overlaps(a, b)) continue;\n      const cardPeak = card.rect.peak(a, b);\n      console.log(`\\tFound an overlap at (${Math.round(peak.x)}, ${Math.round(peak.y)})`);\n      if (cardPeak.y > peak.y) peak = cardPeak;\n    }\n\n    return peak;\n  }\n\n}","map":{"version":3,"sources":["/Users/king_ahmed1421/Simba/Ahmed/frontend/src/gallery/utils.ts"],"names":["c","x","y","Rect","constructor","c1","c2","c3","c4","overlaps","a","b","_overlappingIntervals","peak","aY","_h","bY","indexOf","Math","max","rotate","angle","_rotatePoint","toString","round","min","point","PI","cos","sin","interval1","interval2","d","Card","width","height","rect","marginTop","center","marginLeft","copy","CardBucket2D","size","cards","drop","card","cardCopy","w","random","x1","x2","leftPeak","_peak","rightPeak","y1","deltaX","deltaY","console","log","length","push","cardPeak"],"mappings":"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","sourcesContent":["/*** Global Constants ***/\nconst c = (x: number, y: number) => {return {x: x, y: y};};\n\n/*** Interfaces ***/\ninterface CardBucket {\n    /*** Required Representation ***/\n    \n    readonly cards: Array<Card>;\n    readonly size: {width: number, height: number};\n\n    /**\n     * Drops a card into the bucket such that the droped card is either on the floor\n     * of the bucket or is adjacent but not overlapping another card\n     * \n     * @param card to drop into the bucket, must be smaller in size than the bucket\n     */\n    drop(card: Card): void;\n}\n\n/*** Classes ***/\nclass Rect {\n    /*** Representation ***/\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(public readonly c1: {x: number, y: number},\n                public readonly c2: {x: number, y: number},\n                public readonly c3: {x: number, y: number},\n                public readonly c4: {x: number, y: number}) {}\n    \n    /**\n     * Checks if a rectangle overlaps the interval [a, b], requires a <= b\n     * \n     * @param a the start of the interval\n     * @param b the end of the interval\n     * @returns true if this rectangle overlaps [a, b], false otherwise\n     */\n    public overlaps(a: number, b: number): boolean {\n        return this._overlappingIntervals([a, b], [this.c1.x, this.c2.x]) || \n               this._overlappingIntervals([a, b], [this.c4.x, this.c3.x]);\n    }\n\n    /**\n     * Finds the peak of this rectangle, i.e the highest point on this rectangle's within an interval\n     * [a, b], requires a <= b and this rectangle overlap the interval\n     * \n     * Definitions\n     *      peak: the highest point on the perimeter of a rectangle\n     *      ------- <-- any of these points are the highest peak\n     *      |     |\n     *      -------\n     * \n     * \n     * @param a the beggining of the interval\n     * @param b the end of the interval\n     * @returns the peak of this rectangle on the itnerval [a, b]\n     */\n    public peak(a: number, b: number): {x: number, y: number} {\n        const aY = this._h(a);\n        const bY = this._h(b);\n        const x = [a, b, this.c1.x, this.c2.x, this.c3.x, this.c4.x];\n        const y = [aY, bY, this.c1.y, this.c2.y, this.c3.y, this.c4.y];\n        return {x: x[y.indexOf(Math.max(...y))], y: Math.max(...y)};\n    }\n\n    /**\n     * Rotates a rectangle by an angle about the center of the rectangle\n     * \n     * @param angle the angle to rotate the rectangle by, in degrees\n     * @returns \n     */\n    public rotate(angle: number): Rect {\n        const c1 = this._rotatePoint(angle, this.c1);\n        const c2 = this._rotatePoint(angle, this.c2);\n        const c3 = this._rotatePoint(angle, this.c3);\n        const c4 = this._rotatePoint(angle, this.c4);\n        return new Rect(c1, c2, c3, c4);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public toString(): string {\n        return `----- Rect -----\\n\\tC1: (${Math.round(this.c4.x)}, ${Math.round(this.c4.y)})\\n\\tC2: (${Math.round(this.c3.x)}, ${Math.round(this.c3.y)})\\n\\tC3: (${Math.round(this.c1.x)}, ${Math.round(this.c1.y)})\\n\\tC4: (${Math.round(this.c2.x)}, ${Math.round(this.c2.y)})\\n\\t----- ---- -----`;\n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Calculates the hieght of any point along the domain of the rectangle\n     * \n     * @param x a number on the domain of the rectangle \n     * @returns the height of the rectangle at point x\n     */\n    private _h(x: number): number {\n        if (Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x) > x) return 0;\n        if (Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x) < x) return 0;\n\n        return (this.c3.y - this.c4.y) / (this.c3.x - this.c4.x) * (x - this.c3.x) + this.c3.y;\n    } \n\n    /**\n     * Rotates a point by the given angle \n     * R(x, y, 𝜽) = (x*cos(𝜽)) - y*sin(𝜽), x*sin(𝜽) + y*cos(𝜽))\n     * \n     * @param angle to rotate the point by, in degrees\n     * @param point to rotate\n     * @returns the coordinates of the rotates point\n     */\n    private _rotatePoint(angle: number, point: {x: number, y: number}): {x: number, y: number} {\n        angle *= Math.PI / 180;\n        return {x: point.x * Math.cos(angle) - point.y * Math.sin(angle), y: point.x * Math.sin(angle) + point.y * Math.cos(angle)};\n    }\n    \n    /**\n     * Checks if two intervals overlap, requires each interval to be of the form [a, b]\n     * where a <= b\n     * \n     * Definitions\n     *      overlap: line segments sharing a segement\n     *                  -------\n     *             -------\n     *  \n     * @param interval1 the first interval\n     * @param interval2 the second interval\n     * @returns true if the intervals overlap, false otherwise\n     */\n    private _overlappingIntervals(interval1: [number, number], interval2: [number, number]): boolean {\n        const [a, b] = interval1;\n        const [c, d] = interval2;\n\n        if (d < a || b < c) return false;\n        return true;\n    }\n}\n\nexport class Card {\n    /*** Representation ***/\n    public angle = 0;\n    public rect: Rect;\n    public marginTop = 0;\n    public center: number;\n    public marginLeft = 0;\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly width: number, readonly height: number) {\n        this.rect = new Rect(c(0, 0), c(width, 0), c(width, height), c(0, height));\n        this.center = width / 2;\n    }\n\n    /**\n     * \n     */\n    public copy(): Card {\n        const copy = new Card(this.width, this.height);\n        copy.rect = this.rect;\n        copy.center = this.center;\n        copy.marginTop = this.marginTop;\n        copy.marginLeft = this.marginLeft;\n        return copy;\n    }\n    /**\n     * @inheritdoc\n     */\n    public toString(): string {\n        return `----- Card -----\\n\\t${this.rect}\\n\\tCenter: ${this.center}\\n\\tRotation Angle: ${this.angle}\\n\\tMarginTop: ${this.marginTop}\\n\\tMarginLeft: ${this.marginLeft}`   \n    }\n}\n\nexport class CardBucket2D implements CardBucket {\n    /*** Representation ***/\n    readonly cards: Card[] = [];\n\n    /** \n     * AF(cards) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly size: {width: number, height: number}) {}\n\n    /** @inheritdoc */\n    public drop(card: Card): void {\n        const cardCopy = card.copy();\n        const w = cardCopy.width;\n        cardCopy.center = Math.random() * (this.size.width - w) + w / 2;\n        \n        const x1 = cardCopy.center - w / 2; \n        const x2 = cardCopy.center + w / 2;\n        \n        cardCopy.marginLeft = x1;\n        cardCopy.rect = new Rect(c(x1, 0), c(x2, 0), c(x2, cardCopy.height), c(x1, cardCopy.height));\n        \n        const leftPeak = this._peak(x1, cardCopy.center - 1);\n        const rightPeak = this._peak(cardCopy.center, x2);\n        \n        const y1 = Math.max(leftPeak.y, rightPeak.y);\n        cardCopy.rect = new Rect(c(x1, y1), c(x2, y1), c(x2, y1 + cardCopy.height), c(x1, y1 + cardCopy.height));\n\n        const deltaX = leftPeak.y - rightPeak.y\n        const deltaY = leftPeak.x - rightPeak.x\n\n        // if (deltaX !== 0) cardCopy.angle = Math.atan(deltaY / deltaX) * 180 / Math.PI;\n\n        // cardCopy.rect = cardCopy.rect.rotate(cardCopy.angle);\n        cardCopy.marginTop = this.size.height - (cardCopy.rect.c1.y + cardCopy.rect.c2.y) / 2;\n\n        if (cardCopy.marginTop < 0) this.drop(card);\n        \n        console.log(`Dropped card ${this.cards.length}:\\n${cardCopy}`);\n        this.cards.push(cardCopy);\n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Finds the card with the highest peak within the interval [a, b]\n     * \n     * @param a the start of the interval, must be 0 <= a <= this.width\n     * @param b the end of the interval, must be 0 <= a < b <= this.width\n     * @returns the coordinates of the peak within the interval and has the heighest peak\n     */\n    private _peak(a: number, b: number): {x: number, y: number} {\n        console.log(`Searching for overlap on [${Math.round(a)}, ${Math.round(b)}] ....`)\n        let peak = {x: a, y: 0};\n        for (const card of this.cards) {\n            if (!card.rect.overlaps(a, b)) continue;\n            const cardPeak = card.rect.peak(a, b);\n            console.log(`\\tFound an overlap at (${Math.round(peak.x)}, ${Math.round(peak.y)})`);\n            if (cardPeak.y > peak.y) peak = cardPeak;\n        }\n        return peak;\n    }\n}"]},"metadata":{},"sourceType":"module"}