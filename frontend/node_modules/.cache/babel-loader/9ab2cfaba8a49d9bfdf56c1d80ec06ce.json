{"ast":null,"code":"/*** Global Constants ***/\n\n/*** Interfaces ***/\n\n/*** Classes ***/\nclass Rect {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  overlaps(a, b) {\n    if (a <= this.x1 && this.x1 <= b) return true;\n    if (a <= this.x2 && this.x2 <= b) return true;\n    return false;\n  }\n\n}\n\nexport class Card {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.angle = 0;\n    this.rect = void 0;\n    this.margin = 0;\n    this.center = void 0;\n    this.rect = new Rect(0, 0, width, height);\n    this.center = width / 2;\n  }\n  /**\n   * \n   * @param a \n   * @param b \n   */\n\n\n  peak(a, b) {\n    const x2 = this.width * Math.cos(this.angle);\n    const y2 = this.width * Math.sin(this.angle) + this.rect.y2;\n\n    const f = x => (this.rect.y1 - y2) / (this.rect.x1 - x2) * (x - x2) + y2;\n\n    console.log(`Finding the peak of (${this.rect.x1}, ${x2}) on interval (${a}, ${b})`);\n    console.log(`x1: ${this.rect.x1} -> ${f(this.rect.x1)}\\nx2: ${x2} -> ${f(x2)}\\na: ${a} -> ${f(a)}\\nb: ${b} -> ${f(b)}`);\n    if (this.rect.x1 < a && b < x2) return f(a) > f(b) ? {\n      x: a,\n      y: f(a)\n    } : {\n      x: b,\n      y: f(b)\n    };\n    if (this.rect.x1 < a && b > x2) return f(a) > f(x2) ? {\n      x: a,\n      y: f(a)\n    } : {\n      x: x2,\n      y: f(x2)\n    };\n    if (this.rect.x1 > a && b > x2) return f(this.rect.x1) > f(x2) ? {\n      x: this.rect.x1,\n      y: f(this.rect.x1)\n    } : {\n      x: x2,\n      y: f(x2)\n    };\n    if (this.rect.x1 >= a && b <= x2) return f(this.rect.x1) > f(b) ? {\n      x: this.rect.x1,\n      y: f(this.rect.x1)\n    } : {\n      x: b,\n      y: f(b)\n    };else throw new Error(\"Specification violated\");\n  }\n\n}\nexport class CardBucket2D {\n  /*** Representation ***/\n\n  /** \n   * AF(cards) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(size) {\n    this.size = size;\n    this.cards = [];\n  }\n  /** @inheritdoc */\n\n\n  drop(card) {\n    const w = card.width;\n    const center = Math.random() * (this.size.width - w + 1) + w / 2;\n\n    const leftPeak = this._peak(center - w / 2, center);\n\n    const rightPeak = this._peak(center, center + w / 2);\n\n    card.center = center;\n    card.margin = (leftPeak.y + rightPeak.y) / 2;\n    if (card.margin !== 0) card.angle = Math.atan((leftPeak.y - rightPeak.y) / (leftPeak.x - rightPeak.x));\n    this.cards.push(card);\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Finds the card with the highest peak within the interval [a, b]\n   * \n   * @param a the start of the interval, must be 0 <= a <= this.width\n   * @param b the end of the interval, must be 0 <= a < b <= this.width\n   * @returns the coordinates of the peak within the interval and has the heighest peak\n   */\n\n\n  _peak(a, b) {\n    let peak = {\n      x: 0,\n      y: 0\n    };\n\n    for (const card of this.cards) {\n      if (!card.rect.overlaps(a, b)) continue;\n      console.log(\"Found an overlap!\");\n      const cardPeak = card.peak(a, b);\n      if (cardPeak.y > peak.y || cardPeak.y === peak.y && cardPeak.x > peak.x) peak = cardPeak;\n    }\n\n    return peak;\n  }\n\n}","map":{"version":3,"sources":["/Users/king_ahmed1421/Simba/Ahmed/frontend/src/gallery/utils.ts"],"names":["Rect","constructor","x1","y1","x2","y2","overlaps","a","b","Card","width","height","angle","rect","margin","center","peak","Math","cos","sin","f","x","console","log","y","Error","CardBucket2D","size","cards","drop","card","w","random","leftPeak","_peak","rightPeak","atan","push","cardPeak"],"mappings":"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","sourcesContent":["/*** Global Constants ***/\n\n/*** Interfaces ***/\ninterface CardBucket {\n    /*** Required Representation ***/\n    \n    readonly cards: Array<Card>;\n    readonly size: {width: number, height: number};\n\n    /**\n     * Drops a card into the bucket such that the droped card is either on the floor\n     * of the bucket or is adjacent but not overlapping another card\n     * \n     * @param card to drop into the bucket, must be smaller in size than the bucket\n     */\n    drop(card: Card): void;\n}\n\n/*** Classes ***/\nclass Rect {\n    /*** Representation ***/\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(public readonly x1: number, public readonly y1: number, public readonly x2: number, public readonly y2: number) {}\n\n    public overlaps(a: number, b: number): boolean {\n        if (a <= this.x1 && this.x1 <= b) return true;\n        if (a <= this.x2 && this.x2 <= b) return true;\n        return false;\n    }\n}\nexport class Card {\n    /*** Representation ***/\n    public angle = 0;\n    public rect: Rect;\n    public margin = 0;\n    public center: number;\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly width: number, readonly height: number) {\n        this.rect = new Rect(0, 0, width, height);\n        this.center = width / 2;\n    }\n\n    /**\n     * \n     * @param a \n     * @param b \n     */\n    public peak(a: number, b: number): {x: number, y: number} {\n        const x2 = this.width * Math.cos(this.angle);\n        const y2 = this.width * Math.sin(this.angle) + this.rect.y2;\n        const f = (x: number) => (this.rect.y1 - y2) / (this.rect.x1 - x2) * (x - x2) + y2;\n\n        console.log(`Finding the peak of (${this.rect.x1}, ${x2}) on interval (${a}, ${b})`)\n        console.log(`x1: ${this.rect.x1} -> ${f(this.rect.x1)}\\nx2: ${x2} -> ${f(x2)}\\na: ${a} -> ${f(a)}\\nb: ${b} -> ${f(b)}`)\n        \n        if (this.rect.x1 < a && b < x2) return f(a) > f(b) ? {x: a, y: f(a)} : {x: b, y: f(b)};\n        if (this.rect.x1 < a && b > x2) return f(a) > f(x2) ? {x: a, y: f(a)} : {x: x2, y: f(x2)};\n        if (this.rect.x1 > a && b > x2) return f(this.rect.x1) > f(x2) ? {x: this.rect.x1, y: f(this.rect.x1)} : {x: x2, y: f(x2)};\n        if (this.rect.x1 >= a && b <= x2) return f(this.rect.x1) > f(b) ? {x: this.rect.x1, y: f(this.rect.x1)} : {x: b, y: f(b)};\n        else throw new Error(\"Specification violated\");\n\n    }\n}\n\nexport class CardBucket2D implements CardBucket {\n    /*** Representation ***/\n    readonly cards: Card[] = [];\n\n    /** \n     * AF(cards) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly size: {width: number, height: number}) {}\n\n    /** @inheritdoc */\n    public drop(card: Card): void {\n        const w = card.width;\n        const center = Math.random() * (this.size.width - w + 1) + w / 2;\n\n        const leftPeak = this._peak(center - w / 2, center);\n        const rightPeak = this._peak(center, center + w / 2);\n\n        card.center = center;\n        card.margin = (leftPeak.y + rightPeak.y) / 2;\n        if (card.margin !== 0) card.angle = Math.atan((leftPeak.y - rightPeak.y) / (leftPeak.x - rightPeak.x));\n\n        this.cards.push(card);\n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Finds the card with the highest peak within the interval [a, b]\n     * \n     * @param a the start of the interval, must be 0 <= a <= this.width\n     * @param b the end of the interval, must be 0 <= a < b <= this.width\n     * @returns the coordinates of the peak within the interval and has the heighest peak\n     */\n    private _peak(a: number, b: number): {x: number, y: number} {\n        let peak = {x: 0, y: 0};\n        for (const card of this.cards) {\n            if (!card.rect.overlaps(a, b)) continue;\n            console.log(\"Found an overlap!\")\n\n            const cardPeak = card.peak(a, b);\n            if (cardPeak.y > peak.y || (cardPeak.y === peak.y && cardPeak.x > peak.x)) peak = cardPeak;\n        }\n\n        return peak;\n    }\n}"]},"metadata":{},"sourceType":"module"}