{"ast":null,"code":"/*** Global Constants ***/\nconst c = (x, y) => {\n  return {\n    x: x,\n    y: y\n  };\n};\n/*** Interfaces ***/\n\n\n/*** Classes ***/\nclass Rect {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(c1, c2, c3, c4) {\n    this.c1 = c1;\n    this.c2 = c2;\n    this.c3 = c3;\n    this.c4 = c4;\n  }\n\n  overlaps(a, b) {\n    const c = Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x);\n    const d = Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x);\n    if (a <= d && d <= b) return true;\n    if (a >= c && d <= b) return true;\n    if (a >= c && c <= b) return true;\n    return false;\n  }\n  /**\n   * \n   * @param a \n   * @param b \n   * @returns \n   */\n\n\n  peak(a, b) {\n    const aY = this._h(a);\n\n    const bY = this._h(b);\n\n    const x = [a, b, this.c3.x, this.c4.x];\n    const y = [aY, bY, this.c3.y, this.c4.y];\n    return {\n      x: x[x.indexOf(Math.max(...y))],\n      y: Math.max(...y)\n    };\n  }\n  /**\n   * \n   * @param angle \n   * @returns \n   */\n\n\n  rotate(angle) {\n    const c1 = this._rotatePoint(angle, this.c1);\n\n    const c2 = this._rotatePoint(angle, this.c2);\n\n    const c3 = this._rotatePoint(angle, this.c3);\n\n    const c4 = this._rotatePoint(angle, this.c4);\n\n    return new Rect(c1, c2, c3, c4);\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Calculates the hieght of any point along the domain of the rectangle\n   * \n   * @param x a number on the domain of the rectangle \n   * @returns the height of the rectangle at point x\n   */\n\n\n  _h(x) {\n    if (Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x) > x) return 0;\n    if (Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x) < x) return 0;\n    return (this.c3.y - this.c4.y) / (this.c3.x - this.c4.x) * (x = this.c3.x) + this.c3.y;\n  }\n  /**\n   * \n   * @param angle \n   * @param point \n   * @returns \n   */\n\n\n  _rotatePoint(angle, point) {\n    const rectCenter = {\n      x: (this.c1.x + this.c2.x) / 2,\n      y: (this.c1.y + this.c4.y) / 2\n    };\n\n    const v = this._euclid_dist(point, rectCenter);\n\n    console.log(v);\n    return {\n      x: v * (point.y * Math.cos(angle) + point.x * Math.sin(angle)),\n      y: v * (point.x * Math.cos(angle) - point.y * Math.sin(angle))\n    };\n  }\n  /**\n   * \n   * @param p1 \n   * @param p2 \n   * @returns \n   */\n\n\n  _euclid_dist(p1, p2) {\n    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5;\n  }\n\n}\n\nexport class Card {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.angle = 0;\n    this.rect = void 0;\n    this.marginTop = 0;\n    this.center = void 0;\n    this.marginLeft = 0;\n    this.rect = new Rect(c(0, 0), c(width, 0), c(width, height), c(0, height));\n    this.center = width / 2;\n  }\n\n}\nexport class CardBucket2D {\n  /*** Representation ***/\n\n  /** \n   * AF(cards) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(size) {\n    this.size = size;\n    this.cards = [];\n  }\n  /** @inheritdoc */\n\n\n  drop(card) {\n    const w = card.width;\n    const center = Math.random() * (this.size.width - w + 1) + w / 2;\n    const x1 = center - w / 2;\n    const x2 = center + w / 2;\n    card.marginLeft = x1;\n\n    const leftPeak = this._peak(x1, center);\n\n    const rightPeak = this._peak(center, x2);\n\n    const y1 = Math.max(leftPeak.y, rightPeak.y);\n    card.rect = new Rect(c(x1, y1), c(x2, y1), c(x2, y1 + card.height), c(x1, y1 + card.height));\n    const deltaX = leftPeak.y - rightPeak.y;\n    const deltaY = leftPeak.x - rightPeak.x;\n    if (deltaX !== 0) card.angle = -Math.atan(deltaY / deltaX);\n    card.rect = card.rect.rotate(card.angle);\n    card.marginTop = this.size.width - (card.rect.c1.y + card.rect.c2.y) / 2;\n    this.cards.push(card);\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Finds the card with the highest peak within the interval [a, b]\n   * \n   * @param a the start of the interval, must be 0 <= a <= this.width\n   * @param b the end of the interval, must be 0 <= a < b <= this.width\n   * @returns the coordinates of the peak within the interval and has the heighest peak\n   */\n\n\n  _peak(a, b) {\n    let peak = {\n      x: 0,\n      y: 0\n    };\n\n    for (const card of this.cards) {\n      if (!card.rect.overlaps(a, b)) continue;\n      const cardPeak = card.rect.peak(a, b);\n      if (cardPeak.y > peak.y) peak = cardPeak;\n    }\n\n    return peak;\n  }\n\n}","map":{"version":3,"sources":["/Users/king_ahmed1421/Simba/Ahmed/frontend/src/gallery/utils.ts"],"names":["c","x","y","Rect","constructor","c1","c2","c3","c4","overlaps","a","b","Math","min","d","max","peak","aY","_h","bY","indexOf","rotate","angle","_rotatePoint","point","rectCenter","v","_euclid_dist","console","log","cos","sin","p1","p2","Card","width","height","rect","marginTop","center","marginLeft","CardBucket2D","size","cards","drop","card","w","random","x1","x2","leftPeak","_peak","rightPeak","y1","deltaX","deltaY","atan","push","cardPeak"],"mappings":"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","sourcesContent":["/*** Global Constants ***/\nconst c = (x: number, y: number) => {return {x: x, y: y};};\n\n/*** Interfaces ***/\ninterface CardBucket {\n    /*** Required Representation ***/\n    \n    readonly cards: Array<Card>;\n    readonly size: {width: number, height: number};\n\n    /**\n     * Drops a card into the bucket such that the droped card is either on the floor\n     * of the bucket or is adjacent but not overlapping another card\n     * \n     * @param card to drop into the bucket, must be smaller in size than the bucket\n     */\n    drop(card: Card): void;\n}\n\n/*** Classes ***/\nclass Rect {\n    /*** Representation ***/\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(public readonly c1: {x: number, y: number},\n                public readonly c2: {x: number, y: number},\n                public readonly c3: {x: number, y: number},\n                public readonly c4: {x: number, y: number}) {}\n\n    public overlaps(a: number, b: number): boolean {\n        const c = Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x);\n        const d = Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x);\n\n        if (a <= d && d <= b) return true;\n        if (a >= c && d <= b) return true;\n        if (a >= c && c <= b) return true;\n        return false;\n    }\n\n    /**\n     * \n     * @param a \n     * @param b \n     * @returns \n     */\n    public peak(a: number, b: number): {x: number, y: number} {\n        const aY = this._h(a);\n        const bY = this._h(b);\n        const x = [a, b, this.c3.x, this.c4.x];\n        const y = [aY, bY, this.c3.y, this.c4.y];\n\n        return {x: x[x.indexOf(Math.max(...y))], y: Math.max(...y)};\n        \n\n    }\n\n    /**\n     * \n     * @param angle \n     * @returns \n     */\n    public rotate(angle: number): Rect {\n        const c1 = this._rotatePoint(angle, this.c1);\n        const c2 = this._rotatePoint(angle, this.c2);\n        const c3 = this._rotatePoint(angle, this.c3);\n        const c4 = this._rotatePoint(angle, this.c4);\n\n        return new Rect(c1, c2, c3, c4);\n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Calculates the hieght of any point along the domain of the rectangle\n     * \n     * @param x a number on the domain of the rectangle \n     * @returns the height of the rectangle at point x\n     */\n    private _h(x: number): number {\n        if (Math.min(this.c1.x, this.c2.x, this.c3.x, this.c4.x) > x) return 0;\n        if (Math.max(this.c1.x, this.c2.x, this.c3.x, this.c4.x) < x) return 0;\n\n        return (this.c3.y - this.c4.y) / (this.c3.x - this.c4.x) * (x = this.c3.x) + this.c3.y;\n    } \n\n    /**\n     * \n     * @param angle \n     * @param point \n     * @returns \n     */\n    private _rotatePoint(angle: number, point: {x: number, y: number}): {x: number, y: number} {\n        const rectCenter = {x: (this.c1.x + this.c2.x) / 2, y: (this.c1.y + this.c4.y) / 2};\n\n        const v = this._euclid_dist(point, rectCenter);\n        console.log(v)\n        return {x: v*(point.y * Math.cos(angle) + point.x * Math.sin(angle)), y: v*(point.x * Math.cos(angle) - point.y * Math.sin(angle))}\n    }\n\n    /**\n     * \n     * @param p1 \n     * @param p2 \n     * @returns \n     */\n    private _euclid_dist(p1: {x: number, y: number}, p2: {x: number, y: number}): number {return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5;}\n}\n\nexport class Card {\n    /*** Representation ***/\n    public angle = 0;\n    public rect: Rect;\n    public marginTop = 0;\n    public center: number;\n    public marginLeft = 0;\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly width: number, readonly height: number) {\n        this.rect = new Rect(c(0, 0), c(width, 0), c(width, height), c(0, height));\n        this.center = width / 2;\n    }\n}\n\nexport class CardBucket2D implements CardBucket {\n    /*** Representation ***/\n    readonly cards: Card[] = [];\n\n    /** \n     * AF(cards) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly size: {width: number, height: number}) {}\n\n    /** @inheritdoc */\n    public drop(card: Card): void {\n        const w = card.width;\n        const center = Math.random() * (this.size.width - w + 1) + w / 2;\n\n        const x1 = center - w / 2; \n        const x2 = center + w / 2;\n        card.marginLeft = x1;\n\n        const leftPeak = this._peak(x1, center);\n        const rightPeak = this._peak(center, x2);\n        const y1 = Math.max(leftPeak.y, rightPeak.y);\n        card.rect = new Rect(c(x1, y1), c(x2, y1), c(x2, y1 + card.height), c(x1, y1 + card.height));\n\n        const deltaX = leftPeak.y - rightPeak.y\n        const deltaY = leftPeak.x - rightPeak.x\n        if (deltaX !== 0) card.angle = - Math.atan(deltaY / deltaX);\n\n        card.rect = card.rect.rotate(card.angle);\n        card.marginTop = this.size.width - (card.rect.c1.y + card.rect.c2.y) / 2;\n\n        this.cards.push(card);\n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Finds the card with the highest peak within the interval [a, b]\n     * \n     * @param a the start of the interval, must be 0 <= a <= this.width\n     * @param b the end of the interval, must be 0 <= a < b <= this.width\n     * @returns the coordinates of the peak within the interval and has the heighest peak\n     */\n    private _peak(a: number, b: number): {x: number, y: number} {\n        let peak = {x: 0, y: 0};\n        for (const card of this.cards) {\n            if (!card.rect.overlaps(a, b)) continue;\n\n            const cardPeak = card.rect.peak(a, b);\n            if (cardPeak.y > peak.y) peak = cardPeak;\n        }\n\n        return peak;\n    }\n}"]},"metadata":{},"sourceType":"module"}