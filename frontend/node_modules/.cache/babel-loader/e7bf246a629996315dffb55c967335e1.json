{"ast":null,"code":"/*** Global Constants ***/\n\n/*** Interfaces ***/\n\n/*** Classes ***/\nclass Rect {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  overlaps(a, b) {\n    if (a <= this.x1 && this.x1 <= b) return true;\n    if (a <= this.x2 && this.x2 <= b) return true;\n    return false;\n  }\n\n}\n\nexport class Card {\n  /*** Representation ***/\n\n  /** \n   * AF(width, height, loc) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.angle = 0;\n    this.rect = void 0;\n    this.margin = 0;\n    this.center = void 0;\n    this.rect = new Rect(0, 0, width, height);\n    this.center = width / 2;\n  }\n\n}\nexport class CardBucket2D {\n  /*** Representation ***/\n\n  /** \n   * AF(cards) =\n   * \n   * Representation Invariant\n   * \n   * Representation Exposure\n   * \n   */\n  constructor(size) {\n    this.size = size;\n    this.cards = [];\n  }\n  /** @inheritdoc */\n\n\n  drop(card) {\n    const w = card.width;\n    const center = Math.random() * (this.size.width - w + 1) + w / 2;\n    const x1 = center - w / 2;\n    const x2 = center + w / 2;\n\n    const peak = this._peak(x1, x2);\n\n    card.center = center;\n    card.margin = peak;\n    card.rect = new Rect(x1, card.margin, x2, card.margin + card.height);\n    this.cards.push(card);\n  }\n  /*** Helper Methods ***/\n\n  /**\n   * Finds the card with the highest peak within the interval [a, b]\n   * \n   * @param a the start of the interval, must be 0 <= a <= this.width\n   * @param b the end of the interval, must be 0 <= a < b <= this.width\n   * @returns the coordinates of the peak within the interval and has the heighest peak\n   */\n\n\n  _peak(a, b) {\n    let peak = 0;\n\n    for (const card of this.cards) {\n      if (!card.rect.overlaps(a, b)) continue;\n      console.log(\"Found an overlap!\"); // const cardPeak = card.peak(a, b);\n\n      const cardPeak = card.rect.y2;\n      if (cardPeak > peak) peak = cardPeak;\n    }\n\n    return peak;\n  }\n\n}","map":{"version":3,"sources":["/Users/king_ahmed1421/Simba/Ahmed/frontend/src/gallery/utils.ts"],"names":["Rect","constructor","x1","y1","x2","y2","overlaps","a","b","Card","width","height","angle","rect","margin","center","CardBucket2D","size","cards","drop","card","w","Math","random","peak","_peak","push","console","log","cardPeak"],"mappings":"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","sourcesContent":["/*** Global Constants ***/\n\n/*** Interfaces ***/\ninterface CardBucket {\n    /*** Required Representation ***/\n    \n    readonly cards: Array<Card>;\n    readonly size: {width: number, height: number};\n\n    /**\n     * Drops a card into the bucket such that the droped card is either on the floor\n     * of the bucket or is adjacent but not overlapping another card\n     * \n     * @param card to drop into the bucket, must be smaller in size than the bucket\n     */\n    drop(card: Card): void;\n}\n\n/*** Classes ***/\nclass Rect {\n    /*** Representation ***/\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(public readonly x1: number, public readonly y1: number, public readonly x2: number, public readonly y2: number) {}\n\n    public overlaps(a: number, b: number): boolean {\n        if (a <= this.x1 && this.x1 <= b) return true;\n        if (a <= this.x2 && this.x2 <= b) return true;\n        return false;\n    }\n}\nexport class Card {\n    /*** Representation ***/\n    public angle = 0;\n    public rect: Rect;\n    public margin = 0;\n    public center: number;\n\n    /** \n     * AF(width, height, loc) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly width: number, readonly height: number) {\n        this.rect = new Rect(0, 0, width, height);\n        this.center = width / 2;\n    }\n}\n\nexport class CardBucket2D implements CardBucket {\n    /*** Representation ***/\n    readonly cards: Card[] = [];\n\n    /** \n     * AF(cards) =\n     * \n     * Representation Invariant\n     * \n     * Representation Exposure\n     * \n     */\n\n    constructor(readonly size: {width: number, height: number}) {}\n\n    /** @inheritdoc */\n    public drop(card: Card): void {\n        const w = card.width;\n        const center = Math.random() * (this.size.width - w + 1) + w / 2;\n\n        const x1 = center - w / 2; \n        const x2 = center + w / 2;\n        const peak = this._peak(x1, x2);\n\n        card.center = center;\n        card.margin = peak;\n        card.rect = new Rect(x1, card.margin, x2, card.margin + card.height);\n\n        this.cards.push(card);\n    }\n\n    /*** Helper Methods ***/\n    /**\n     * Finds the card with the highest peak within the interval [a, b]\n     * \n     * @param a the start of the interval, must be 0 <= a <= this.width\n     * @param b the end of the interval, must be 0 <= a < b <= this.width\n     * @returns the coordinates of the peak within the interval and has the heighest peak\n     */\n    private _peak(a: number, b: number): number {\n        let peak = 0;\n        for (const card of this.cards) {\n            if (!card.rect.overlaps(a, b)) continue;\n            console.log(\"Found an overlap!\")\n\n            // const cardPeak = card.peak(a, b);\n            const cardPeak = card.rect.y2\n            if (cardPeak > peak) peak = cardPeak;\n        }\n\n        return peak;\n    }\n}"]},"metadata":{},"sourceType":"module"}